<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智能投資羅盤 - QA 技術測驗 (60題白話詳解版)</title>
    <style>
        :root {
            --primary-color: #007bff;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --light-bg: #f8f9fa;
            --dark-text: #212529;
            --light-text: #6c757d;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background-color: var(--light-bg); color: var(--dark-text); line-height: 1.6; padding: 20px; max-width: 800px; margin: auto; }
        h1, h2 { color: var(--primary-color); text-align: center; }
        .quiz-wrapper { background-color: #fff; border-radius: 12px; padding: 25px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .question-block { display: none; }
        .question-block.active { display: block; }
        .progress-bar { width: 100%; background-color: #e9ecef; border-radius: 20px; margin-bottom: 20px; }
        .progress-bar-inner { height: 10px; width: 0%; background-color: var(--primary-color); border-radius: 20px; transition: width 0.4s ease; }
        .question-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .question-counter { font-weight: 600; font-size: 1.1em; }
        .question-text { font-weight: 600; margin-bottom: 20px; font-size: 1.2em; }
        .options label { display: flex; align-items: center; margin-bottom: 12px; padding: 12px 15px; border-radius: 8px; cursor: pointer; border: 2px solid transparent; background-color: var(--light-bg); transition: all 0.2s; }
        .options label:hover { border-color: var(--primary-color); }
        .options input { margin-right: 12px; transform: scale(1.2); }
        .options label.selected { border-color: var(--primary-color); background-color: #e7f3ff; }
        .options label.correct { border-color: var(--success-color); background-color: #eaf6ec; font-weight: bold; }
        .options label.incorrect { border-color: var(--danger-color); background-color: #fbe9ec; }
        .button-container { text-align: center; margin-top: 25px; }
        .quiz-button { background-color: var(--primary-color); color: #fff; border: none; padding: 12px 35px; font-size: 1.1em; border-radius: 8px; cursor: pointer; transition: all 0.3s; }
        .quiz-button:hover { background-color: #0069d9; transform: translateY(-2px); }
        .quiz-button:disabled { background-color: #a0aec0; cursor: not-allowed; transform: none; }
        .explanation { margin-top: 20px; padding: 15px; background-color: #e9ecef; border-left: 5px solid var(--primary-color); border-radius: 8px; font-size: 1em; display: none; }
        .explanation.visible { display: block; animation: fadeIn 0.5s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        #results-screen { display: none; text-align: center; }
        #results-screen h2 { margin-bottom: 20px; }
        #final-score { font-size: 2.5em; font-weight: bold; margin-bottom: 25px; }
        .wrong-answers-list { text-align: left; margin-top: 20px; }
        .wrong-answer-item { margin-bottom: 20px; padding: 15px; background-color: var(--light-bg); border-radius: 8px; }
        .wrong-answer-item p { margin: 5px 0; }
        .wrong-answer-item .user-answer { color: var(--danger-color); font-weight: bold; }
        #start-screen, #quiz-screen { display: none; }
        #start-screen.active, #quiz-screen.active { display: block; }
    </style>
</head>
<body>

    <div class="quiz-wrapper">
        <div id="start-screen" class="active">
            <h1>智能投資羅盤 - QA 技術測驗</h1>
            <h2>(60題白話詳解版)</h2>
            <p style="text-align: center;">本測驗將以一題一答的方式進行，每題作答後會立即顯示詳解。請準備好後開始。</p>
            <div class="button-container">
                <button id="start-button" class="quiz-button">開始測驗</button>
            </div>
        </div>

        <div id="quiz-screen">
            <div class="question-header">
                <div class="question-counter" id="question-counter"></div>
            </div>
            <div class="progress-bar">
                <div class="progress-bar-inner" id="progress-bar-inner"></div>
            </div>
            <div id="quiz-form"></div>
            <div class="button-container">
                <button id="submit-button" class="quiz-button">確認送出</button>
            </div>
        </div>

        <div id="results-screen">
            <h2>測驗結束！</h2>
            <div id="final-score"></div>
            <div class="wrong-answers-list">
                <h3>錯誤題目回顧：</h3>
                <div id="wrong-answers-container"></div>
            </div>
            <div class="button-container">
                <button id="restart-button" class="quiz-button">重新測驗</button>
            </div>
        </div>
    </div>

<script>
    const quizData = [
        { question: "1. 我們的後端採用 Flask 框架而非 Django，主要考量是什麼？", options: [ "A. Flask 的安全性遠高於 Django。", "B. Flask 內建了比 Django 更強大的機器學習函式庫。", "C. 系統以 API 為核心，Flask 輕量、靈活的特性更適合快速開發與部署 API 服務。", "D. Flask 對資料庫的支援種類比 Django 更多。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。可以把 Django 想像成一個**精美的樂高城堡盒組**，功能齊全但很龐大；而 Flask 則像是一堆**基礎的樂高積木**。因為我們只想蓋一個API服務的「碉堡」，用基礎積木（Flask）自己蓋，遠比改造整個城堡（Django）來得快又有效率。" },
        { question: "2. 我們使用 Cloudflare Tunnel 進行部署，它解決了哪個核心安全問題？", options: [ "A. 防止資料庫被 SQL Injection 攻擊。", "B. 無需在伺服器防火牆上開放任何入站端口，杜絕了針對 IP 的直接攻擊。", "C. 自動壓縮前端的 JavaScript 和 CSS 檔案。", "D. 確保 Python 程式碼不會被反編譯。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。想像你的電腦是一間房子，開放網路端口就像在家開了一扇窗。Cloudflare Tunnel 像是蓋了一條**從你家直達銀行的秘密地道**，你不用開窗也能辦事，壞人自然就無法從窗戶爬進來攻擊你的房子（伺服器IP）了。" },
        { question: "3. 處理耗時的「策略訓練」任務時，我們採用了非同步任務佇列架構。這個架構如何改善使用者體驗？", options: [ "A. 讓訓練過程的計算速度變得更快。", "B. 後端立即回應「任務已提交」，並在背景執行運算，避免前端頁面卡死或請求超時。", "C. 減少了資料庫的讀寫次數。", "D. 可以讓多個使用者同時訓練同一支股票。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。就像你去生意很好的餐廳點餐。服務生（後端API）不會讓你站在原地等餐點做好，而是先給你一個號碼牌（任務ID）讓你回座位，廚房（背景Worker）則在後面慢慢做。你可以隨時看叫號燈（查詢狀態），等餐好了再去取。這樣你就不用一直罰站，體驗很好。" },
        { question: "4. `utils.py` 在我們的專案中扮演了什麼關鍵角色？", options: [ "A. 儲存所有使用者的帳號密碼。", "B. 專門用來繪製 Plotly 互動圖表。", "C. 作為一個輔助工具模組，提供了資料庫連接、績效指標計算等可重用的核心函式。", "D. 負責管理 Flask 伺服器的啟動與關閉。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。`utils.py` 就像一個**共用的工具箱**。裡面放著像是「螺絲起子」（連接資料庫）和「計算機」（計算績效）這類大家都會用到的工具。這樣不管誰需要，都去同一個工具箱拿，不用每個人都自己買一套，程式碼才不會重複又整潔。" },
        { question: "5. 相較於傳統單目標遺傳演算法，NSGA-II 在我們專案中的最大優勢是什麼？", options: [ "A. 它的運算速度比傳統 GA 快數倍。", "B. 它能保證找到在未來市場中必定獲利的策略。", "C. 它的演算法原理比傳統 GA 更簡單直觀。", "D. 能夠同時優化多個衝突的目標(如報酬率與風險)，並找出一個包含多種權衡解的「帕累托前沿」。" ], answer: 3, explanation: "<strong>正確答案：D</strong>。就像玩電玩選角色，你不能說「攻擊力100、防禦力100」的角色就是唯一最好的。NSGA-II 不會只找出「攻擊力最高」的角色，而是會給你一個**英雄榜**：「高攻擊低防禦的刺客」、「攻守均衡的戰士」、「高防禦低攻擊的坦克」。這些都是好選擇，端看玩家（使用者）喜歡哪種風格。" },
        { question: "6. 我們設計了系統 A (28基因) 和系統 B (10基因) 兩種策略，主要目的是什麼？", options: [ "A. 系統 A 專為台股設計，系統 B 專為美股設計。", "B. 探索策略的「複雜度」與「穩健性」之間的權衡，A追求更高性能上限，B追求更強的穩健性。", "C. 系統 A 使用趨勢策略，系統 B 使用反轉策略。", "D. 因為 NSGA-II 演算法要求至少有兩種不同的基因長度。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。系統 A 就像一輛零件超多、調校空間極大的 **F1 賽車**，潛力無限但容易在崎嶇路面（未來市場）出問題。系統 B 則像一輛零件較少但堅固耐用的**越野拉力賽車**，性能上限可能沒那麼高，但更穩健、能適應各種路況。我們提供兩種車讓使用者選擇。" },
        { question: "7. 在 `ga_engine.py` 中，我們自定義了 `ValidGASampling` 類別，其主要用途是什麼？", options: [ "A. 確保演算法在交叉(Crossover)過程中不會出錯。", "B. 確保演算法在初始階段生成的基因都符合內在的邏輯約束(如短期均線天期<長期均線天期)。", "C. 讓演算法可以支援更多種類的技術指標。", "D. 用於將最終找到的最佳基因儲存到資料庫。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。就像舉辦一場比賽，這個步驟是**賽前資格審查**。如果讓「短期均線50天，長期均線10天」這種不合邏輯的選手進場比賽，只會浪費時間和資源。這個類別確保了所有最初的參賽者都是合格的，比賽才能順利開始。" },
        { question: "8. 演算法如何處理在回測中完全不產生任何交易的策略？", options: [ "A. 直接給予最高的評分，因為它沒有產生任何虧損。", "B. 透過一個「交易次數懲罰因子」，大幅降低這種策略的適應度分數(Fitness)，使其被淘汰。", "C. 忽略這些策略，不參與後續的演化。", "D. 系統會強制讓它至少交易一次。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。一個完全不交易的策略就像一個在考場上交白卷的學生，雖然沒寫錯任何答案，但分數是零。我們的系統會給這種「躺平」的策略一個**超低分**，確保它在比賽中被淘汰掉。" },
        { question: "9. 在「智能資金配置」功能中，Gemini AI 的分析結果如何具體影響最終的配置比例？", options: [ "A. 直接取代歷史數據分析，完全由 AI 決定最終的配置比例。", "B. 僅提供文字分析報告，不影響任何數值計算。", "C. 作為一個動態調整因子，根據即時新聞情緒對量化歷史回測得出的基礎分數進行加權調整。", "D. 它的分析結果只用於「策略最新信號」頁面，與資金配置無關。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。量化分析就像看一個學生的**歷史成績**，而 AI 分析就像是打電話問**最近的班導師**。如果一個學生過去成績很好，但班導師說他最近沉迷玩樂，我們可能就會稍微降低對他的期望。AI 就是扮演班導師的角色，用即時新聞來微調基於歷史數據的分數。" },
        { question: "10. 面對 yfinance 的數據源不穩定及台股代號格式問題，我們的 `EnhancedStockAnalyzer` 採取了什麼策略？", options: [ "A. 當 yfinance 失敗時，改用另一個付費的數據源。", "B. 如果數據載入失敗，就直接顯示錯誤，讓使用者自己修正代號。", "C. 對於數字代號，會自動依序嘗試加上 `.TW` 和 `.TWO` 後綴進行查詢，直到成功為止。", "D. 系統會快取所有股票過去一年的數據，完全避免即時查詢。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。就像一個聰明的快遞員，當你只給他一個地址的門牌號碼（如 2330），他會自己**先試試看是不是在「台北市」（.TW）**，如果不是，他會**再試試看是不是在「新北市」（.TWO）**，而不是直接回報說找不到路。這讓使用者更方便。" },
        { question: "11. 在`offline_ga_trainer.py`腳本中，其主要功能是什麼？", options: [ "A. 啟動 Flask 網站伺服器。", "B. 批次地、自動化地為股票清單中的每一支股票運行多次 GA/NSGA-II 演算法，並將最佳結果存入資料庫。", "C. 監控伺服器狀態，如果當機則自動重啟。", "D. 每日自動從 Google News 抓取新聞並進行情緒分析。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。這個程式就像一個**策略的生產工廠**。我們晚上讓它自己加班，把清單上所有股票都生產一遍，做出最好的策略模型。這樣白天使用者來查詢時，就可以直接從倉庫（資料庫）裡拿出成品，而不用現場等待生產。" },
        { question: "12. 我們的系統實現了 PWA (Progressive Web App)，這為使用者帶來的主要好處是什麼？", options: [ "A. 讓網站的執行速度比原生 App 更快。", "B. 可以將網站「安裝」到手機或電腦桌面，並支援基本的離線訪問。", "C. 自動為使用者過濾掉所有廣告。", "D. PWA 是一種後端技術，與使用者體驗無關。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。PWA 就像是給一個網站**施了魔法**，讓它可以從瀏覽器裡「跳出來」，變成一個**手機桌面上的圖示**，就像真的 App 一樣。而且它會偷偷記住網站的樣子，就算沒網路也能打開看，體驗更好。" },
        { question: "13. 在 `index_page.html` 的 CSS 中，手動回測結果的英雄式指標網格 (`hero-metric-grid`) 設計，主要目的是什麼？", options: [ "A. 為了讓頁面看起來更美觀，沒有特殊功能意涵。", "B. 這是 Plotly 圖表的預設樣式，無法修改。", "C. 透過資訊層次化設計，用更大的字體和突出的位置，引導使用者首先關注「總報酬、年化報酬、最大回撤」這三個最核心的指標。", "D. 為了在手機版上可以自動隱藏，節省空間。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。這就像一份報紙的**頭版頭條**。我們會用最大最粗的字體標出今天最重要的新聞。同樣地，我們用這個設計把「總共賺多少？」、「每年平均賺多少？」和「最多可能賠多少？」這三件使用者最關心的事，放在最顯眼的地方。" },
        { question: "14. `service-worker.js` 這個檔案在 PWA 架構中的核心作用是什麼？", options: [ "A. 負責處理所有與後端 API 的通訊。", "B. 執行遺傳演算法的核心計算。", "C. 儲存使用者的登入狀態。", "D. 作為一個在背景運行的腳本，攔截網路請求並管理快取，從而實現離線可用性。" ], answer: 3, explanation: "<strong>正確答案：D</strong>。`service-worker` 就像一個**網站的小管家**，住在你的瀏覽器裡。當你要看網頁時，它會先檢查自己口袋（快取）裡有沒有，如果有就直接拿給你，超快！如果沒有，它才會跑去跟網路要。這樣就算斷網，小管家還是能把口袋裡的東西拿給你看。" },
        { question: "15. 為何在回測圖表生成時，我們要同時產生一個靜態的 `.png` 圖片和一個互動的 `.html` 檔案？", options: [ "A. `.png` 是備份，以防 `.html` 檔案損壞。", "B. `.png` 檔案比 `.html` 檔案更清晰。", "C. 為了提升使用者體驗：在卡片中快速載入輕量的 `.png` 預覽圖，點擊後才在彈出視窗中載入功能完整但較大的互動式 `.html` 圖表。", "D. 這是 Plotly 函式庫的強制要求。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。這就像餐廳的菜單。`.png` 是菜單上的**小照片**，讓你可以快速瀏覽所有菜色。`.html` 則是當你對某道菜有興趣時，服務生端上來的**可以互動的試吃品**。先看照片再決定要不要試吃，體驗流程最順暢。" },
        { question: "16. 在 NSGA-II 的每一代演化中，第一個也是最關鍵的步驟是什麼？", options: [ "A. 變異 (Mutation)。", "B. 交叉 (Crossover)。", "C. 執行「非支配排序 (Non-dominated Sorting)」將族群分入不同的帕累托前沿 (Pareto Fronts)。", "D. 計算每個解的夏普比率。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。這就像一場比賽的第一步：**排位賽**。在做任何淘汰或晉級之前，演算法必須先根據所有選手（策略）的綜合表現，把他們分到不同的等級（金牌組、銀牌組、銅牌組）。這個分級的過程就是「非支配排序」。" },
        { question: "17. 在完成「非支配排序」後，NSGA-II 使用「擁擠度計算 (Crowding Distance)」的主要目的是什麼？", options: [ "A. 為了計算每個策略的總報酬率。", "B. 為了懲罰交易次數過少的策略。", "C. 在同一層級的帕累托前沿中，優先選擇處於較稀疏區域的解，以保持解的多樣性。", "D. 為了加快演算法的收斂速度。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。想像一下我們要組一支籃球隊，在所有頂尖球員（同一層帕累托前沿）中，我們不希望全部都選身高 210 公分的中鋒。擁擠度計算就是為了確保我們**選一些後衛、一些前鋒**，讓隊伍的**組合更多元、不單調**，避免所有最佳策略都長得太像。" },
        { question: "18. 什麼是「帕累托最優解 (Pareto Optimal Solution)」？", options: [ "A. 在所有目標上都達到最高分的單一最佳解。", "B. 一個在多個目標權衡下的「不後悔」解。意思是，找不到任何其他解能在所有目標上都比它好或跟它一樣好。", "C. 交易次數最多且勝率最高的解。", "D. 演算法運行時間最短的解。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。這個概念是 NSGA-II 的核心。想像一下，在帕累托前沿上有兩個策略 A 和 B。策略 A 的報酬率可能比 B 高，但風險也比 B 大。我們不能絕對地說 A 就比 B 好，因為這取決於投資者的風險偏好。這兩個策略都是「不後悔」的選擇，都是帕累托最優解。演算法的目標就是找出這樣一整組的權衡解。" },
        { question: "19. 我們的演算法使用「錦標賽選擇法 (Tournament Selection)」來挑選父代進行繁殖。這個方法的運作方式是？", options: [ "A. 直接選擇每一代中適應度分數最高的前 10% 個體。", "B. 隨機挑選一小組個體，並從中選擇帕累托層級最高、擁擠度最大的個體作為勝者。", "C. 將所有個體依照報酬率排序，然後依序挑選。", "D. 優先選擇基因序列最長的策略。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。這就像舉辦一場**小型淘汰賽**。我們不會一開始就讓所有人大亂鬥，而是隨機抓幾個人（一小組）出來比一比。誰的綜合排名（帕累托層級）最高，而且風格最獨特（擁擠度最大），誰就勝出，獲得晉級（繁殖）的資格。" },
        { question: "20. 在我們的基因編碼中，一個像 `rsi_p = 2` 這樣的基因值，實際代表什麼？", options: [ "A. 代表 RSI 的週期直接設定為 2 天。", "B. 代表 RSI 的計算權重為 2。", "C. 代表從預先定義的 RSI 週期選項列表 `[7, 14, 21]` 中，選擇索引為 2 的選項 (即 21 天)。", "D. 這是一個無意義的數值，僅供演算法內部使用。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。基因就像一張**選擇題的答案卡**。基因值是 `2`，不代表答案本身是 2，而是代表你去我們預先準備好的選項列表（題庫）中，選擇第 3 個選項（索引從0開始，所以2是第3個）。這樣可以確保所有參數都在我們設定的合理範圍內。" },
        { question: "21. 我們使用了「模擬二元交叉 (SBX)」和「多項式變異 (PM)」操作，它們在演化過程中的核心作用是？", options: [ "A. 負責評估每個策略的適應度分數。", "B. 負責從父代基因生成新的子代基因，探索新的可能性。", "C. 負責將無效的基因從族群中移除。", "D. 負責將最終結果儲存到資料庫。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。這就像**父母生小孩**。「交叉」就像小孩會遺傳到爸爸的眼睛和媽媽的頭髮，組合了父母雙方的優良特性。「變異」則像是小孩突然出現了父母都沒有的獨特天賦（例如很會畫畫），這為家族帶來了新的可能性。" },
        { question: "22. 系統 A 和系統 B 的基因長度不同 (28 vs 10)，這對演算法的「搜索空間」有何影響？", options: [ "A. 沒有影響，演算法會自動適應。", "B. 系統 A 的搜索空間遠大於系統 B，理論上可能找到更優的解，但也更容易陷入局部最優。", "C. 基因長度越短，搜索空間越大。", "D. 基因長度只影響計算速度，不影響搜索空間。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。搜索空間就像一個**藏寶地圖的大小**。系統 A 的地圖超級大（28個基因），裡面可能藏著驚天大寶藏，但也很容易在某個角落迷路。系統 B 的地圖比較小（10個基因），雖然可能沒有那麼驚人的寶藏，但比較容易找到所有不錯的寶物。" },
        { question: "23. 在`select_best_from_pareto`函式中，我們最終是如何從一組帕累托最優解中，挑選出一個策略推薦給使用者的？", options: [ "A. 隨機挑選一個。", "B. 總是挑選總報酬率最高的那一個。", "C. 根據使用者在前端設定的權重，對所有帕累托解的各項指標進行加權評分，選出綜合得分最高者。", "D. 總是挑選最大回撤最低的那一個。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。演算法找出的帕累托前沿是一份**客觀的「優質菜單」**。而使用者在前端調整權重，就像是告訴服務生他的**主觀「口味偏好」**（例如「我喜歡辣一點」）。服務生會根據你的口味，從菜單上推薦最適合你的那道菜。" },
        { question: "24. NSGA-II 中的「精英策略 (Elitism)」確保了什麼？", options: [ "A. 每一代的族群規模都會增加。", "B. 每一代的最佳解（帕累托前沿）不會比上一代更差。", "C. 變異操作不會產生無效的基因。", "D. 只有交易次數最多的策略才能被選中。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。精英策略就像一個**「種子選手」保護機制**。在每一輪比賽後，我們會確保上一屆的冠軍（最佳解）直接晉級下一輪，不會因為運氣不好在淘汰賽中被意外刷掉。這保證了比賽的整體水準只會越來越高，不會退步。" },
        { question: "25. 為什麼在 NSGA-II 的目標函數中，我們需要將「最大化總報酬」轉換為「最小化負總報酬」？", options: [ "A. 為了讓所有目標的數值都在 0 和 1 之間。", "B. 為了增加計算的複雜度。", "C. 因為 `pymoo` 框架的 `minimize` 函式預設是解決最小化問題，所以需要將最大化目標取反。", "D. 這只是一種程式碼風格，沒有實際作用。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。這是一個簡單的數學小技巧。想像一下，你要找一群人裡**身高最高**的人。這和找一群人裡「**負身高」最小**的人是同一件事。因為我們的工具（pymoo）只會找「最小值」，所以我們就把想找「最大值」的目標前面加個負號，讓它幫我們找。" },
        { question: "26. (多選題) 系統 A (28基因) 的策略庫中，內建了哪幾種交易策略邏輯？", type: "checkbox", options: [ "A. MA Cross (均線交叉)", "B. Triple EMA (三重指數移動平均)", "C. MACD + KD Crossover", "D. BB+RSI (布林帶 + 相對強弱指數)", "E. BB+ADX (布林帶 + 平均趨向指標)", "F. ATR+KD (真實波幅 + 隨機指標)", "G. BB+MACD (布林帶 + MACD)", "H. VIX + ATR Volatility Breakout" ], answer: [0, 1, 3, 4, 5, 6], explanation: "<strong>正確答案：A, B, D, E, F, G</strong>。<br>根據 `ga_engine.py` 中的 `STRAT_NAMES` 列表，系統 A 完整的 8 種策略庫為：<br>1. MA Cross<br>2. Triple EMA<br>3. MA+MACD+RSI<br>4. EMA+RSI<br>5. BB+RSI<br>6. BB+ADX<br>7. ATR+KD<br>8. BB+MACD<br>選項 C 和 H 是我們系統中未包含的虛構組合。" },
        { question: "27. 我們的策略模型使用 VIX 指數作為市場狀態的判斷基準。當 VIX 高於基因設定的閾值時，系統會如何改變行為？", options: [ "A. 立即賣出所有持倉並停止交易。", "B. 從預設的「常規策略 (`normal_strat`)」切換到「避險策略 (`risk_off_strat`)」。", "C. 降低所有交易的手續費計算比例。", "D. 增加 RSI 指標的計算週期以降低敏感度。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。VIX 就像**天氣預報**。當 VIX 很高，就代表外面可能要刮颱風了（市場恐慌）。這時，系統會自動從「晴天模式」的策略，切換到「颱風天模式」的策略，用更謹慎或不同的方法來應對市場。" },
        { question: "28. 在系統 B (10基因) 的低波動市場進場邏輯中，觸發買入的條件是什麼？", options: [ "A. RSI 指標低於 30。", "B. 股價觸及布林帶下軌。", "C. 短期均線 (5日) 向上穿越長期均線 (10日)，即「黃金交叉」。", "D. ADX 指標高於 40。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。在系統 B 的設計中，當市場風平浪靜（低波動）時，它會採用最經典的戰術之一：**小船（短期均線）超車大船（長期均線）**時，就認為是個上漲的好時機，於是發出買入信號。" },
        { question: "29. 系統 B 在高波動市場下，提供了兩種進場策略 (BB+RSI 或 BB+ADX)。這兩種策略的核心邏輯差異在哪？", options: [ "A. BB+RSI 是趨勢追蹤策略，BB+ADX 是反轉策略。", "B. BB+RSI 試圖在超賣時抄底 (反轉)，而 BB+ADX 則是在確認下跌趨勢強度時尋找反彈機會。", "C. 兩者沒有差異，只是使用的指標不同。", "D. BB+RSI 用於美股，BB+ADX 用於台股。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。BB+RSI 像是一個**機會主義者**，看到股價跌到一個極端（超賣）就想進去撿便宜，賭它會反彈。BB+ADX 則更像一個**謹慎的獵人**，它不僅要看到股價跌到低點，還要確認「風很大」（ADX確認趨勢），才認為這是一個值得參與的反彈行情。" },
        { question: "30. 在資料庫中，`ai_vs_user_games` 表和 `saved_strategies` 表的核心區別是什麼？", options: [ "A. `ai_vs_user_games` 儲存系統 A 的策略，`saved_strategies` 儲存系統 B 的策略。", "B. `ai_vs_user_games` 儲存由離線訓練器自動產生的各股票最佳策略，而 `saved_strategies` 儲存使用者手動收藏或訓練的個人化策略。", "C. 兩者結構完全相同，只是為了備份。", "D. `ai_vs_user_games` 儲存失敗的訓練記錄，`saved_strategies` 儲存成功的。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。`ai_vs_user_games` 就像是**公立圖書館**，裡面放著系統為大家準備好的暢銷書（預訓練策略）。`saved_strategies` 則是你**個人的書架**，上面放著你從圖書館借來的書、或是你自己寫的讀書筆記（自己訓練的策略）。" },
        { question: "31. `backtest_signals` 這張表的主要用途是什麼？", options: [ "A. 儲存所有使用者的登入記錄。", "B. 每日排程回測任務執行後，用來儲存那些在近期觸發了明確買入或賣出信號的策略結果，以驅動「信號」頁面的顯示。", "C. 快取從 yfinance 獲取的歷史股價。", "D. 記錄使用者在資金配置器中的操作。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。這張表就像**電視台的晚間新聞快報**。每天收盤後，我們的排程任務會當記者，去採訪所有策略，把有最新消息（買賣信號）的策略寫成新聞稿放在這裡。第二天使用者打開「信號」頁面，看到的就是這份最新的新聞快報。" },
        { question: "32. 我們為什麼選擇使用 `TEXT` 或 `JSON` 類型來儲存策略的 `gene`，而不是為每個基因參數創建單獨的欄位？", options: [ "A. `TEXT/JSON` 類型佔用的儲存空間更小。", "B. 為了**保持架構的靈活性**，這樣同一張表就可以儲存不同長度（如系統 A 的 28 個和系統 B 的 10 個）的基因，而無需修改資料庫結構。", "C. 因為資料庫不支援儲存數字陣列。", "D. 這樣查詢速度會更快。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。這就像用一個**可以伸縮的魔法袋（JSON）**來裝東西，而不是用一個有很多固定小格子的盒子。今天想裝 10 個小東西（系統B基因），明天想裝 28 個（系統A基因），魔法袋都能輕鬆應付。如果用固定格子，每次東西數量一變，就得換一個新盒子，非常麻煩。" },
        { question: "33. 在 `saved_strategies` 表中，`last_signal_type` 和 `last_signal_date` 這兩個欄位的資料是由哪個系統模組負責更新的？", options: [ "A. 使用者在前端手動更新。", "B. 由 Flask 主程式在使用者登入時更新。", "C. 由一個每日執行的**背景排程任務 (`UserStrategyMonitor`)** 自動掃描和更新。", "D. 在使用者儲存策略的當下就固定下來，不再變動。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。「我的策略」頁面上的狀態標籤（持有中/賣出）之所以每天都可能是新的，就是因為有一個**勤勞的小機器人（排程任務）**每天半夜都會起來，把你收藏的每個策略都拿最新的股價跑一遍，然後更新它們的最新狀態。" },
        { question: "34. 「策略庫 (Explorer)」功能的核心目的是什麼？", options: [ "A. 讓使用者可以和其他人分享自己的策略。", "B. 作為一個「策略市場」，讓使用者可以購買更高級的策略。", "C. 在使用者進行耗時的**全新訓練之前**，提供一個快速查詢入口，讓他們可以先看看系統是否已經為這支股票預先訓練好了優質策略。", "D. 顯示所有使用者儲存策略的排行榜。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。它的核心價值是**節省使用者的時間和精力**。就像你想吃一道功夫菜，與其自己從頭買菜、備料、花好幾個小時做，不如先去**餐廳的菜單（策略庫）**上看看有沒有現成的。如果有，直接點餐（收藏）就好了。" },
        { question: "35. 在「手動回測器」中，系統在什麼情況下會提示「近期有買入/賣出訊號」？", options: [ "A. 只要回測結果是獲利的。", "B. 當回測的**結束日期**被設定為**執行當天**時。", "C. 只要回測期間內的交易次數超過 10 次。", "D. 只有在使用系統 A 的基因進行回測時。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。這個提示就像一個**天氣預報**。只有當你查詢包含「今天」的天氣時，預報員才能告訴你「嘿，今天下午可能會下雨喔！」（近期有信號）。如果你查的是上個月的天氣，預報員就只會告訴你過去的歷史紀錄了。" },
        { question: "36. 「智能資金配置器」聲稱其建議基於三大支柱，以下何者**不是**其中之一？", options: [ "A. 策略的歷史量化回測績效。", "B. 使用者選擇的個人風險偏好（保守/均衡/積極）。", "C. 使用者帳戶的總資產規模。", "D. 由 Gemini AI 分析的即時市場新聞與情緒。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。我們的配置器像一個**食譜產生器**，它告訴你做一道菜需要「30%的麵粉、70%的水」，也就是**比例**。它不關心你總共有多少麵粉（總資產），只專注於給出最佳的材料配比。" },
        { question: "37. 我們在回測結果中同時提供了「夏普比率 (Sharpe Ratio)」和「索提諾比率 (Sortino Ratio)」。索提諾比率相較於夏普比率，在評估風險時有何不同？", options: [ "A. 索提諾比率只考慮了上漲時的波動，而忽略了下跌風險。", "B. 索提諾比率在計算風險時，**只考慮了有害的下方波動（下跌）**，而夏普比率則將所有波動（無論漲跌）都視為風險。", "C. 索提諾比率的計算比夏普比率更簡單快速。", "D. 兩者沒有區別，只是名稱不同。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。夏普比率就像一個**緊張兮兮的教練**，只要隊員有任何情緒起伏（無論是興奮大笑還是沮喪哭泣）他都覺得是風險。索提諾比率則是個**更聰明的教練**，他覺得興奮大笑（股價上漲）是好事，只有沮喪哭泣（股價下跌）才是真正需要管理的風險。" },
        { question: "38. 在「我的策略」頁面，勾選多個策略後，為什麼「資金配置」按鈕會自動禁用 ticker 重複的策略？", options: [ "A. 這是系統的一個 bug。", "B. 因為在同一個投資組合中對同一支股票配置多個不同策略，在邏輯上是衝突且難以執行的。", "C. 為了限制使用者一次最多只能配置 5 個策略。", "D. 只有 VIP 使用者才能對同一支股票配置多個策略。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。這是一個**防止使用者自我矛盾**的設計。想像一下，你同時請了兩個軍師，一個跟你說「全力進攻A點！」，另一個說「趕快從A點撤退！」。那你到底該聽誰的？為了避免這種混亂，系統不允許你將針對同一個目標（股票）的矛盾指令放在同一個計劃（投資組合）裡。" },
        { question: "39. 在資金配置結果中，AI 為每個策略分配了如「核心增長」、「穩定基石」、「衛星配置」等角色，其判斷依據是什麼？", options: [ "A. 根據股票的市值大小。", "B. 根據股票所屬的產業類別。", "C. 根據策略的**量化分數**和**穩定性分數**的組合，得分最高者為核心，穩定性最強者為基石，其餘為衛星。", "D. 隨機分配。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。這就像**組建一支軍隊**。綜合戰鬥力最強的（量化總分最高）當作**主力部隊（核心增長）**；最不容易被打敗、防禦力最強的（穩定性分數最高）當作**後方防線（穩定基石）**；剩下的則當作可以靈活調動的**游擊隊（衛星配置）**。" },
        { question: "40. 我們的離線訓練腳本 (`offline_ga_trainer.py`) 中設定了「智能暫停機制」，其目的是什麼？", options: [ "A. 為了讓伺服器有時間休息，防止過熱。", "B. 在大量、連續地向 yfinance API 請求數據時，透過短暫暫停來避免因請求頻率過高而被臨時封鎖。", "C. 為了在暫停期間執行資料庫備份。", "D. 為了等待使用者輸入指令。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。yfinance 就像一個**免費的自助餐**，但餐廳有個不成文的規定：你不能一次拿太多盤，也不要跑得太頻繁，不然老闆會覺得你在浪費。我們的暫停機制就像是很有禮貌地**吃完一盤，稍微休息一下再去拿下一盤**，這樣老闆才不會把你趕出去（IP被封鎖）。" },
        { question: "41. 一位使用者想為一支新的、不在我們預設清單中的台股 (如 6789.TWO) 尋找策略，他應該遵循的最佳路徑是什麼？", options: [ "A. 直接去「信號」頁面，等待系統自動出現信號。", "B. 先去「策略庫」查詢，如果查不到，再去「訓練器」自行設定權重並啟動一次新訓練。", "C. 只能透過修改 `tw_stock.csv` 檔案來新增股票。", "D. 寫信給客服，請求手動為這支股票新增策略。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。這是我們設計的標準流程：**先查（策略庫），再造（訓練器）**。就像你想找一本書，應該先去圖書館查查看有沒有，如果圖書館真的沒有，你再考慮自己寫一本。而且，當你在訓練器成功查詢後，系統會自動把這支股票加入清單，下次就不用再找了。" },
        { question: "42. 如果使用者在「訓練器」中將「回撤懲罰」權重調到最高 (1.0)，其他都設為 0，他最有可能得到什麼樣的策略？", options: [ "A. 一個總報酬率極高，但波動劇烈的策略。", "B. 一個交易次數非常頻繁的短線策略。", "C. 一個在歷史回測中**最大資金回撤幅度極低**的策略，但其總報酬率可能不是最高的。", "D. 一個勝率接近 100% 的策略。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。權重就像你給 AI 下的**指令**。把「回撤懲罰」調到滿分，就等於你對 AI 大喊：「我什麼都不要，我就是要安全！我最討厭賠錢的感覺！」AI 就會盡全力去找一個**過程最平穩、虧損幅度最小**的策略，即使這個策略賺的錢不是最多的。" },
        { question: "43. 我們的系統使用了 `apscheduler` 來執行每日排程任務。這與 `main_app備分.py` 中的背景訓練 Worker 執行緒有何不同？", options: [ "A. `apscheduler` 只能執行非常簡單的任務，而 Worker 執行緒可以執行複雜的計算。", "B. 兩者沒有區別，只是實現方式不同。", "C. `apscheduler` 負責**按預定時間觸發**任務（如每日17:30），而 Worker 執行緒則負責處理由**使用者即時觸發**、放入佇列中的任務。", "D. `apscheduler` 是前端技術，Worker 執行緒是後端技術。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。`apscheduler` 就像一個**鬧鐘**，每天固定時間響起，提醒系統去做固定的事情（如每日掃描）。而 Worker 執行緒則像一個**隨時待命的工人**，只要有新的訂單（使用者訓練請求）進來，他就馬上開始工作。一個是「時間驅動」，一個是「事件驅動」。" },
        { question: "44. 在`main_app備分.py`的`create_backtest_chart_assets`函式中，我們為圖表 URL 加上了 `?v={int(time.time())}` 這樣的後綴，這是為了什麼？", options: [ "A. 為了記錄圖表生成的時間。", "B. 這是一種安全加密措施。", "C. 為了**防止瀏覽器快取**。這確保了每次使用者重新回測時，都能看到最新生成的圖表，而不是瀏覽器中儲存的舊版本。", "D. 為了讓 URL 看起來更長、更專業。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。瀏覽器很懶，看到同一個網址的圖片會直接拿舊的來看。我們在網址後面加一個**每次都不同的「版本號」**（時間戳），就像每次都給圖片換個新名字。這樣瀏覽器就會以為是全新的圖片，只好乖乖地去伺服器拿最新的版本。" },
        { question: "45. 如果我們要為系統增加一個「使用者偏好設定」頁面（例如，預設的風險偏好），從資料庫的角度，最合理的做法是什麼？", options: [ "A. 在 `saved_strategies` 表中新增欄位。", "B. 在 `users` 表中新增相關欄位（如 `default_risk_profile`），因為這些設定是跟隨使用者的。", "C. 創建一個全新的 `user_preferences` 表。", "D. 將設定直接儲存在前端的 `localStorage` 中，不涉及資料庫。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。就像整理房間，**跟「人」有關的東西，就應該放在「個人資料」的抽屜裡**。風險偏好是使用者的個人屬性，所以直接在 `users` 這張記錄個人資料的表中增加一欄，是最直接、最符合邏輯的做法。" },
        { question: "46. 為什麼在`offline_trainer.py`中，我們需要呼叫`calculate_detailed_metrics_for_traditional_ga`重新計算一次績效，而不是直接使用演算法返回的 fitness？", options: [ "A. 因為演算法返回的 fitness 經過了**交易次數懲罰**的調整，它不等於策略的真實總報酬率，需要用標準化函式重新計算才能獲得準確的各項指標。", "B. 演算法返回的 fitness 是加密的，需要解密。", "C. 這是一個重複的步驟，可以被優化掉。", "D. 為了將績效轉換為美元計算。" ], answer: 0, explanation: "<strong>正確答案：A</strong>。演算法在比賽中用的分數 (`fitness`) 和最終公布的官方成績單（`metrics`）是兩回事。比賽分數可能因為「運動家精神」（交易次數）而有加分或減分。但最終的成績單必須是**純粹、客觀**的表現數據，所以我們需要用一個標準的函式，把所有加減分去掉，重新計算一次。" },
        { question: "47. 整個系統中，哪一個部分是實現「個人化」投資策略的核心？", options: [ "A. 「信號」頁面，因為它會顯示最新的市場機會。", "B. 「訓練器」頁面，因為它允許使用者透過**調整因子權重**來影響演算法的尋優方向，從而生成符合其風險偏好的策略。", "C. 「策略庫」頁面，因為它收藏了所有股票的策略。", "D. 登入頁面，因為它驗證了使用者的身份。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。訓練器是唯一一個能讓使用者**把自己的投資想法「告訴」AI** 的地方。使用者調整權重，就等於在對 AI 說：「我這個人比較怕風險，你幫我找個穩一點的策略吧！」這是從無到有創造個人化策略的起點。" },
        { question: "48. 我們的前端介面是作為一個 SPA (單頁應用) 實現的。這意味著什麼？", options: [ "A. 整個網站只有一個 `index_page.html` 頁面，所有的頁面切換都是透過 JavaScript 在前端動態改變內容，而不是向伺服器請求一個全新的 HTML 頁面。", "B. 網站的所有功能都只能在一個頁面內完成。", "C. 網站不需要後端伺服器即可運行。", "D. 網站只能被單一使用者同時訪問。" ], answer: 0, explanation: "<strong>正確答案：A</strong>。SPA 就像一本**魔法書**。你第一次打開時需要下載整本書，但之後你翻頁時，書頁上的文字和圖畫會**瞬間變化**，而不需要每次都重新從書架上拿一本新書。這讓使用者感覺操作非常流暢、沒有延遲。" },
        { question: "49. 我們的`main_app備分.py`在啟動時會執行`run_user_strategies_scan`排程任務，這個任務的目的是？", options: [ "A. 刪除超過30天未使用的舊策略。", "B. 重新訓練所有使用者儲存的策略以適應最新市場。", "C. 檢查所有使用者儲存的策略，在**近期市場數據下的最新持倉狀態**（買入/賣出/持有/無倉位），並更新資料庫。", "D. 為所有使用者策略生成績效排行榜。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。這個任務就像一個**私人助理**，每天早上會幫你把你關心的所有公司（你收藏的策略）的最新狀況都檢查一遍，然後在你的筆記本上更新狀態標籤（例如「這家今天有利多！」或「這家沒動靜」）。這樣你一打開筆記本，所有狀況就一目了然。" },
        { question: "50. 考慮到整個系統的複雜度，如果發生了一個難以追蹤的錯誤，你認為哪個工具或檔案是進行除錯(Debug)的第一站？", options: [ "A. `tw_stock.csv` 股票清單。", "B. `manifest.json` PWA設定檔。", "C. **伺服器日誌 (`offline_trainer_b.log` 或 Flask 執行的控制台輸出)**，因為它記錄了從 API 請求到資料庫操作再到演算法執行的每一步詳細資訊。", "D. `login.html` 的原始碼。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。伺服器日誌就像飛機的**「黑盒子」**。當系統出問題時，這個黑盒子記錄了墜毀前發生的所有事情：哪個API被呼叫、資料庫發生了什麼錯誤、演算法在哪一行程式碼卡住了。這是找到問題根源最重要、最直接的線索。" },
        { question: "51. 根據我們的專題報告書與 `ga_engine.py` 程式碼，NSGA-II 演算法在評估策略時，設定了四個核心優化目標。請問**不包含**以下哪一項？", options: [ "A. 最大化總報酬率 (Total Return)", "B. 最小化最大回撤 (Max Drawdown)", "C. 最大化夏普比率 (Sharpe Ratio)", "D. 最大化平均交易報酬率 (Average Trade Return)" ], answer: 2, explanation: "<strong>正確答案：C</strong>。根據我們的文件和早期程式碼版本，最初的四個目標是**總報酬率、最大回撤、獲利因子(Profit Factor)和平均交易報酬**。雖然夏普比率也是一個重要的指標，但在我們核心的 NSGA-II 目標設定中，是使用獲利因子作為其中一個優化目標的。" },
        { question: "52. 一個策略基因在 NSGA-II 演算法中經歷一次完整的「世代演化」，其主要流程是什麼？", options: [ "A. 評估 -> 變異 -> 交叉 -> 選擇", "B. (父代)評估與排序 -> 選擇 -> 交叉與變異 -> (子代)評估與排序 -> 合併與篩選 -> (新一代)", "C. 交叉 -> 選擇 -> 變異 -> 評估", "D. 選擇 -> 評估 -> 交叉 -> 變異" ], answer: 1, explanation: "<strong>正確答案：B</strong>。這就像一個**完整的選秀和培育流程**：首先評估現有球員（父代），從中挑選最好的進行配對（選擇），讓他們生下有潛力的新球員（交叉與變異），再評估這些新球員（子代），最後從新舊兩代球員中選出最強的隊伍，進入下一個賽季（新一代）。" },
        { question: "53. 在 NSGA-II 的「交叉 (Crossover)」和「變異 (Mutation)」兩個核心操作中，它們各自的目的是什麼？", options: [ "A. 交叉負責產生隨機性，變異負責組合優良特性。", "B. 交叉 (如 SBX) 負責交換兩個優秀父代的部分基因，以組合出可能更優的後代；變異 (如 PM) 則負責對單一基因進行微小的隨機調整，以探索新的可能性並防止陷入局部最優。", "C. 兩者的目的相同，只是隨機化的程度不同。", "D. 交叉只改變基因的順序，變異則改變基因的數值。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。交叉是**「利用」**現有優勢，就像讓兩位神射手結婚，期望生下一個繼承了兩人優點的超級神射手。變異則是**「探索」**未知可能，就像這位超級神射手的孩子突然無師自通學會了灌籃，帶來了全新的驚喜。" },
        { question: "54. 在系統中，「回測器 (Backtester)」功能的主要目的是什麼？它與「訓練器 (Trainer)」有何不同？", options: [ "A. 回測器用來生成新策略，訓練器用來驗證舊策略。", "B. 訓練器是從無到有「生成」一個在特定歷史區間表現最佳的策略；回測器則是讓你拿一個「已知」的策略基因，去驗證它在「任何你指定的股票和時間區間」的表現，核心目的是檢驗策略的穩健性和適應性。", "C. 兩者功能完全相同，只是介面不同。", "D. 回測器只能用於台股，訓練器只能用於美股。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。訓練器就像**「發明家」**，它的目標是發明一台在過去賽道上跑得最快的車。回測器則像**「試車手」**，你可以開著這台發明出來的車，去跑一個全新的、它從沒見過的賽道（比如雨天或山路），看看它是不是真的那麼厲害，還是只會跑舊賽道而已。" },
        { question: "55. 我們的系統提供了「我的策略 (My Strategies)」功能，它的核心價值是什麼？", options: [ "A. 一個公開的市場，讓所有使用者可以互相交易策略。", "B. 一個個人化的策略管理中心，讓使用者可以集中儲存、比較自己收藏或訓練的策略，並透過每日自動更新的「持倉狀態標籤」進行紀律化追蹤。", "C. 系統會自動將表現最好的策略放入所有人的「我的策略」清單中。", "D. 這是唯一可以啟動資金配置功能的地方。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。這個功能就像一個**專屬的武器庫**。你可以把自己發明的（訓練的）或收藏的（從策略庫拿的）武器都放在這裡。最棒的是，每天早上有小精靈會幫你擦亮每一把武器，並在上面掛上「今日適用」或「今日不宜」的標籤，方便你快速選擇。" },
        { question: "56. 如果一個使用者利用我們的「訓練器」生成了一個策略，但在實際投資中造成了巨大虧損，從系統設計和使用者教育的角度，我們應該如何解釋或應對？", options: [ "A. 告訴使用者這是 AI 的錯誤，並承諾賠償。", "B. 歸咎於使用者沒有完全按照信號操作。", "C. 強調「歷史回測不代表未來績效」，並引導使用者關注「樣本外測試」和回測報告中的「最大回撤」等風險指標。說明本系統是「決策輔助工具」，而非「投資建議」。", "D. 立即將該策略的基因從所有資料庫中刪除。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。我們的系統就像一個**超級天氣預報**，它能根據過去100年的數據，告訴你「歷史上符合這種天氣模式時，有80%的機率會下雨」。但它不能保證今天100%會下雨。我們應該提醒使用者，預報是參考用的「輔助工具」，出門要不要帶傘，最終還是要自己決定。" },
        { question: "57. 我們採用 PWA (Progressive Web App) 技術，主要是為了達成什麼目標？", options: [ "A. 讓網站的後端運算速度更快。", "B. 實現「一次開發，多端部署」的跨平台能力。使用者無論在手機、平板還是電腦上，都可以將系統「安裝」到桌面，獲得近乎一致的類原生應用體驗。", "C. 為了完全取代對後端伺服器的依賴。", "D. 這是唯一可以實現離線快取的技術。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。PWA 就像**孫悟空的毫毛**。我們開發一個核心版本（一根毫毛），吹口氣，它就能在手機、電腦、平板上都變出一個幾乎一模一樣的分身（App圖示）。這樣就不用為每個平台都辛苦地重新打造一個，非常有效率。" },
        { question: "58. 除了提供安全隧道 (Tunnel) 外，Cloudflare 在我們的架構中還扮演了另一個關鍵的「效能優化」角色，請問是什麼？", options: [ "A. 自動優化我們的 Python 演算法程式碼。", "B. 作為 CDN (內容分發網路)，它會快取我們網站的靜態資源 (如 HTML/CSS/JS/圖片) 到全球各地的邊緣節點，讓不同地區的使用者都能從最近的伺服器加載，大幅提升網站訪問速度。", "C. 自動為我們的資料庫進行備份。", "D. 提供免費的虛擬主機讓我們運行 Flask。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。Cloudflare 就像在全世界開了很多家**連鎖速食店的前哨站 (CDN)**。當你想看我們網站的一張圖片時，你不用大老遠跑到我們在台灣的總部廚房（主伺服器）來拿，直接去你家巷口那家分店拿就好了，速度當然快得多。" },
        { question: "59. 我們在專案中使用了兩種不同的遺傳演算法引擎 (`ga_engine.py` 和 `ga_engine_b.py`)。這種設計的主要好處是什麼？", options: [ "A. 為了讓專案看起來更複雜。", "B. 實現了模型的「模組化」和「可擴展性」。未來如果我們想引入第三種、第四種完全不同的策略模型（例如基於深度學習的模型），只需再創建一個新的 `ga_engine_c.py`，而無需大規模修改現有架構，展示了系統良好的擴展能力。", "C. 這是 Flask 框架的強制要求。", "D. 為了在兩個引擎之間進行 A/B 測試。" ], answer: 1, explanation: "<strong>正確答案：B</strong>。這就像我們的廚房有**兩個獨立的爐子**，一個專門做中餐（系統A），一個專門做西餐（系統B）。如果未來我們想增加日式料理，只需要再加一個新的爐子，而不用把整個廚房拆掉重建。這讓我們的系統很容易擴充新功能。" },
        { question: "60. 假設使用者在「資金配置器」中選擇了三個策略，其中 Gemini AI 對 A 股票判斷為「樂觀」，B 股票為「中性」，C 股票為「謹慎」。在其他量化指標完全相同的情況下，最終的資金配置比例最可能是怎樣的？", options: [ "A. A = B = C (平均分配)", "B. C > B > A", "C. A > B > C", "D. AI 的判斷不影響比例，只影響文字報告。" ], answer: 2, explanation: "<strong>正確答案：C</strong>。AI 在這裡扮演**裁判**的角色。三位選手（策略）的體能測驗成績（量化指標）都一樣，但裁判（AI）根據場外消息，給了選手 A 一個印象加分（樂觀），給了選手 C 一個印象減分（謹慎）。因此，最終的獎金（資金）分配自然是 A 最多，C 最少。" }
    ];

    let currentQuestionIndex = 0;
    let score = 0;
    let userAnswers = [];

    const startScreen = document.getElementById('start-screen');
    const quizScreen = document.getElementById('quiz-screen');
    const resultsScreen = document.getElementById('results-screen');
    const startButton = document.getElementById('start-button');
    const quizForm = document.getElementById('quiz-form');
    const submitButton = document.getElementById('submit-button');
    const questionCounter = document.getElementById('question-counter');
    const progressBarInner = document.getElementById('progress-bar-inner');
    const finalScore = document.getElementById('final-score');
    const wrongAnswersContainer = document.getElementById('wrong-answers-container');
    const restartButton = document.getElementById('restart-button');

    function startQuiz() {
        startScreen.classList.remove('active');
        quizScreen.classList.add('active');
        showQuestion();
    }

    function showQuestion() {
        quizForm.innerHTML = '';
        const item = quizData[currentQuestionIndex];
        const questionBlock = document.createElement('div');
        questionBlock.className = 'question-block active';
        
        const questionText = document.createElement('p');
        questionText.className = 'question-text';
        questionText.innerHTML = item.question;
        questionBlock.appendChild(questionText);
        
        const optionsDiv = document.createElement('div');
        optionsDiv.className = 'options';
        const inputType = item.type === 'checkbox' ? 'checkbox' : 'radio';

        item.options.forEach((option, optionIndex) => {
            const label = document.createElement('label');
            label.setAttribute('for', `q${currentQuestionIndex}o${optionIndex}`);
            const input = document.createElement('input');
            input.type = inputType;
            input.name = `question${currentQuestionIndex}`;
            input.value = optionIndex;
            input.id = `q${currentQuestionIndex}o${optionIndex}`;
            input.addEventListener('change', () => {
                if(inputType === 'radio') {
                    document.querySelectorAll(`input[name="question${currentQuestionIndex}"]`).forEach(radio => {
                        radio.parentElement.classList.remove('selected');
                    });
                }
                input.parentElement.classList.toggle('selected', input.checked);
                
                const anySelected = document.querySelector(`input[name="question${currentQuestionIndex}"]:checked`);
                submitButton.disabled = !anySelected;
            });
            label.appendChild(input);
            label.appendChild(document.createTextNode(option));
            optionsDiv.appendChild(label);
        });
        questionBlock.appendChild(optionsDiv);
        
        const explanation = document.createElement('div');
        explanation.className = 'explanation';
        explanation.innerHTML = item.explanation;
        questionBlock.appendChild(explanation);
        quizForm.appendChild(questionBlock);

        questionCounter.textContent = `問題 ${currentQuestionIndex + 1} / ${quizData.length}`;
        progressBarInner.style.width = `${((currentQuestionIndex) / quizData.length) * 100}%`;
        submitButton.textContent = '確認送出';
        submitButton.disabled = true;
        submitButton.onclick = checkAnswer;
    }

    function checkAnswer() {
        const item = quizData[currentQuestionIndex];
        const options = document.querySelectorAll(`input[name="question${currentQuestionIndex}"]`);
        const explanation = quizForm.querySelector('.explanation');
        let isCorrect = false;

        let selectedValues = [];
        options.forEach(option => {
            if (option.checked) {
                selectedValues.push(parseInt(option.value));
            }
        });

        if (item.type === 'checkbox') {
            const answer = item.answer.sort();
            selectedValues.sort();
            isCorrect = JSON.stringify(selectedValues) === JSON.stringify(answer);
        } else {
            isCorrect = selectedValues.length === 1 && selectedValues[0] === item.answer;
        }

        userAnswers[currentQuestionIndex] = {
            question: item.question,
            options: item.options,
            selected: selectedValues,
            answer: item.answer,
            explanation: item.explanation,
            isCorrect: isCorrect
        };

        if (isCorrect) {
            score++;
        }
        
        options.forEach((option) => {
            const label = option.parentElement;
            const optionValue = parseInt(option.value);
            
            if (item.type === 'checkbox') {
                if (item.answer.includes(optionValue)) label.classList.add('correct');
                if (option.checked && !item.answer.includes(optionValue)) label.classList.add('incorrect');
            } else {
                 if (optionValue === item.answer) label.classList.add('correct');
                 if (option.checked && optionValue !== item.answer) label.classList.add('incorrect');
            }
            option.disabled = true;
        });

        explanation.classList.add('visible');
        if (currentQuestionIndex < quizData.length - 1) {
            submitButton.textContent = '下一題';
            submitButton.onclick = nextQuestion;
        } else {
            submitButton.textContent = '查看總結';
            submitButton.onclick = showResults;
        }
    }

    function nextQuestion() {
        currentQuestionIndex++;
        progressBarInner.style.width = `${((currentQuestionIndex) / quizData.length) * 100}%`;
        showQuestion();
    }

    function showResults() {
        quizScreen.style.display = 'none';
        resultsScreen.style.display = 'block';

        const scorePercentage = (score / quizData.length) * 100;
        finalScore.textContent = `${score} / ${quizData.length} (${scorePercentage.toFixed(1)}%)`;
        finalScore.style.color = scorePercentage >= 80 ? 'var(--success-color)' : 'var(--danger-color)';

        wrongAnswersContainer.innerHTML = '';
        userAnswers.forEach((answer, index) => {
            if (!answer.isCorrect) {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'wrong-answer-item';
                
                let userAnswerText = '未作答';
                if(answer.selected.length > 0) {
                    userAnswerText = answer.selected.map(i => answer.options[i]).join(', ');
                }

                itemDiv.innerHTML = `
                    <p><strong>問題 ${index + 1}:</strong> ${answer.question}</p>
                    <p>你的答案: <span class="user-answer">${userAnswerText}</span></p>
                    <div class="explanation visible">${answer.explanation}</div>
                `;
                wrongAnswersContainer.appendChild(itemDiv);
            }
        });

        if (wrongAnswersContainer.innerHTML === '') {
            wrongAnswersContainer.innerHTML = '<p style="color: var(--success-color); font-weight: bold;">恭喜！全部答對！</p>';
        }
    }

    startButton.addEventListener('click', startQuiz);
    restartButton.addEventListener('click', () => window.location.reload());
</script>

</body>
</html>
